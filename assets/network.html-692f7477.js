import{_ as h,M as o,p as r,q as l,t as e,R as d,N as c,U as T,a1 as a}from"./framework-201fec1f.js";const n={},p=a('<h1 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> Http</h1><blockquote><p>本篇是对 HTTP 不同版本主要特性的一个概述和总结。</p></blockquote><h2 id="发展历史" tabindex="-1"><a class="header-anchor" href="#发展历史" aria-hidden="true">#</a> 发展历史</h2><ul><li>1991 年 版本：<code>0.9</code> : 只有一个命令 <code>GET</code>, 只能响应 <code>HTML</code></li><li>1996 年 版本：<code>1.0</code> : 引入<code>POST</code>、<code>HEAD</code>, 增加<code>Header</code>, 响应格式丰富</li><li>1997 年 版本：<code>1.1</code> : 引入<code>持久连接</code>、管道机制、<code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code>, 新增<code>Host</code>字段</li><li>20015 版本：<code>2</code> : 二进制、多工、头压缩、服务器推送</li></ul><h2 id="http-1-0" tabindex="-1"><a class="header-anchor" href="#http-1-0" aria-hidden="true">#</a> <code>HTTP 1.0</code></h2><p>早先<code>1.0</code>的<code>HTTP</code>版本，是一种无状态、无连接的应用层协议。</p><p><code>HTTP1.0</code> 规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个<code>TCP</code>连接，服务器处理完成后立即断开<code>TCP</code>连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p>这种无状态性可以借助<code>cookie/session</code>机制来做身份认证和状态记录。而下面两个问题就比较麻烦了。</p><ol><li><p>首先，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次<code>TCP</code>的连接，而<code>TCP</code>的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。</p></li><li><p>其次就是队头阻塞（<code>head of line blocking</code>）。由于<code>HTTP1.0</code>规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。</p></li></ol><p>为了解决这些问题，<code>HTTP1.1</code>出现了。</p><h2 id="http-1-1" tabindex="-1"><a class="header-anchor" href="#http-1-1" aria-hidden="true">#</a> <code>HTTP 1.1</code></h2><p>对于<code>HTTP1.1</code>，不仅继承了<code>HTTP1.0</code>简单的特点，还克服了诸多<code>HTTP1.0</code>性能上的问题。</p><p>首先是长连接，<code>HTTP1.1</code>增加了一个<code>Connection</code>字段，通过设置<code>Keep-Alive</code>可以保持<code>HTTP</code>连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立<code>TCP</code>连接，提高了网络的利用率。如果客户端想关闭<code>HTTP</code>连接，可以在请求头中携带<code>Connection: false</code>来告知服务器关闭请求。</p><p>其次，是<code>HTTP1.1</code>支持请求管道化（<code>pipelining</code>）。基于<code>HTTP1.1</code>的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个 html 页面，页面中包含了很多 img，这个时候<code>keep-alive</code>就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）</p><p>需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p><p>也就是说，<code>HTTP</code>管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。</p><div><img src="https://github.com/sandlz/images/raw/master/uPic/http_01.png"></div><p>如图所示，客户端同时发了两个请求分别来获取<code>html</code>和<code>css</code>，假如说服务器的<code>css</code>资源先准备就绪，服务器也会先发送<code>html</code>再发送<code>css</code>。</p><p>换句话来说，只有等到<code>html</code>响应的资源完全传输完毕后，<code>css</code>响应的资源才能开始传输。也就是说，不允许同时存在两个并行的响应。</p><p>可见，<code>HTTP1.1</code>还是无法解决队头阻塞（<code>head of line blocking</code>）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么就直接默认关闭，并且开启的条件很苛刻...而且实际上好像并没有什么用处。</p><div><img src="https://github.com/sandlz/images/raw/master/uPic/http_02.png"></div>',21),s=d("p",null,[e("其实，虽然 "),d("code",null,"HTTP1.1"),e(" 支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个 "),d("code",null,"TCP"),e(" 的会话。也就是说，上图我们看到的并行，其实是不同的 "),d("code",null,"TCP"),e(" 连接上的 "),d("code",null,"HTTP"),e(" 请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载 "),d("code",null,"6~8"),e(" 个资源的限制。而这，才是真正的并行！")],-1),P=d("code",null,"HTTP1.1",-1),H=d("code",null,"cache-control",-1),u=d("code",null,"Host",-1),m=a('<h2 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0" aria-hidden="true">#</a> <code>HTTP 2.0</code></h2><p>新特性:</p><h3 id="二进制分帧" tabindex="-1"><a class="header-anchor" href="#二进制分帧" aria-hidden="true">#</a> 二进制分帧</h3><p>HTTP2.0 通过在应用层和传输层之间增加一个二进制分帧层，突破了 HTTP1.1 的性能限制、改进传输性能。</p><div><img src="https://github.com/sandlz/images/raw/master/uPic/http_03.jpeg"></div><p>可见，虽然<code>HTTP2.0</code>的协议和<code>HTTP1.x</code>协议之间的规范完全不同了，但是实际上<code>HTTP2.0</code>并没有改变<code>HTTP1.x</code>的语义。 简单来说，<code>HTTP2.0</code>只是把原来<code>HTTP1.x</code>的<code>header</code>和<code>body</code>部分用<code>frame</code>重新封装了一层而已。</p><h3 id="多路复用-连接共享" tabindex="-1"><a class="header-anchor" href="#多路复用-连接共享" aria-hidden="true">#</a> 多路复用（连接共享）</h3><ul><li>流（<code>stream</code>）：已建立连接上的双向字节流</li><li>消息：与逻辑消息对应的完整的一系列数据帧</li><li>帧（<code>frame</code>）：<code>HTTP2.0</code>通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（<code>stream id</code>）</li></ul><div><img src="https://github.com/sandlz/images/raw/master/uPic/http_04.jpeg"></div><p>从图中可见，所有的<code>HTTP2.0</code>通信都在一个<code>TCP</code>连接上完成，这个连接可以承载任意数量的双向数据流。</p><p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（<code>stream id</code>）重新组装。</p><p>举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着<code>stream id</code>用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据<code>stream id</code>将帧再归属到各自不同的请求当中去。</p><p>另外，多路复用（连接共享）可能会导致关键请求被阻塞。<code>HTTP2.0</code>里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。</p><p>可见，<code>HTTP2.0</code>实现了真正的并行传输，它能够在一个<code>TCP</code>上进行任意数量<code>HTTP</code>请求。而这个强大的功能则是基于“二进制分帧”的特性。</p><h3 id="头部压缩" tabindex="-1"><a class="header-anchor" href="#头部压缩" aria-hidden="true">#</a> 头部压缩</h3><p>在<code>HTTP1.x</code>中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加<code>500~800</code>字节的负荷。</p><p>比如说<code>cookie</code>，默认情况下，浏览器会在每次请求的时候，把<code>cookie</code>附在<code>header</code>上面发送给服务器。（由于<code>cookie</code>比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）</p><p><code>HTTP2.0</code>使用<code>encoder</code>来减少需要传输的<code>header</code>大小，通讯双方各自<code>cache</code>一份<code>header fields</code>表，既避免了重复<code>header</code>的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩<code>header</code>，减少发送包的数量从而降低延迟。`</p><h3 id="服务器推送" tabindex="-1"><a class="header-anchor" href="#服务器推送" aria-hidden="true">#</a> 服务器推送</h3><p>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p><h2 id="http1-1-的合并请求是否适用于-http2-0" tabindex="-1"><a class="header-anchor" href="#http1-1-的合并请求是否适用于-http2-0" aria-hidden="true">#</a> <code>HTTP1.1</code> 的合并请求是否适用于 <code>HTTP2.0</code></h2><p>首先，答案是“没有必要”。之所以没有必要，是因为这跟 <code>HTTP2.0</code> 的头部压缩有很大的关系。</p><p>在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典。</p><p>在静态字典中，包含了常见的头部名称以及头部名称与值的组合。静态字典在首次请求时就可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段对应的 index。</p><p>而动态字典跟连接的上下文相关，每个 <code>HTTP/2</code> 连接维护的动态字典是不尽相同的。动态字典可以在连接中不听的进行更新。</p><p>也就是说，原本完整的 <code>HTTP</code> 报文头部的键值对或字段，由于字典的存在，现在可以转换成索引 <code>index</code> ，在相应的端再进行查找还原，也就起到了压缩的作用。</p><p>所以，同一个连接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对 <code>HTTP/2</code> 网站，最佳实践是不要合并资源。</p><p>另外，<code>HTTP2.0</code> 多路复用使得请求可以并行传输，而 <code>HTTP1.1</code> 合并请求的一个原因也是为了防止过多的 HTTP 请求带来的阻塞问题。而现在 <code>HTTP2.0</code> 已经能够并行传输了，所以合并请求也就没有必要了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><h3 id="http1-0" tabindex="-1"><a class="header-anchor" href="#http1-0" aria-hidden="true">#</a> <code>HTTP1.0</code></h3><ul><li>无状态</li><li>无连接</li></ul><h3 id="http1-1" tabindex="-1"><a class="header-anchor" href="#http1-1" aria-hidden="true">#</a> <code>HTTP1.1</code></h3><ul><li>持久连接</li><li>请求管道化</li><li>增加缓存处理（新的字段如 cache-control）</li><li>增加 <code>Host</code> 字段、支持断点传输等</li></ul><h3 id="http2-0" tabindex="-1"><a class="header-anchor" href="#http2-0" aria-hidden="true">#</a> <code>HTTP2.0</code></h3><ul><li>二进制分帧</li><li>多路复用（或连接共享）</li><li>头部压缩</li><li>服务器推送</li></ul>',35),_={href:"https://segmentfault.com/a/1190000013028798",target:"_blank",rel:"noopener noreferrer"};function f(b,x){const t=o("RouterLink"),i=o("ExternalLinkIcon");return r(),l("div",null,[p,e(" 如图所示，绿色部分代表请求发起到服务器响应的一个等待时间，而蓝色部分表示资源的下载时间。按照理论来说，`HTTP`响应理应当是前一个响应的资源下载完了，下一个响应的资源才能开始下载。而这里却出现了响应资源下载并行的情况。这又是为什么呢？ "),s,d("p",null,[e("此外，"),P,e(" 还加入了 "),c(t,{to:"/base/browser/cache.html"},{default:T(()=>[e("缓存处理")]),_:1}),e(" 新的字段如 "),H,e("，支持断点传输，以及增加了 "),u,e(" 字段（使得一个服务器能够用来创建多个 Web 站点）。")]),m,d("p",null,[e("本文转载自"),d("a",_,[e("HTTP主要特性对比"),c(i)])])])}const k=h(n,[["render",f],["__file","network.html.vue"]]);export{k as default};
