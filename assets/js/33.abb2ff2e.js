(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{445:function(t,a,_){"use strict";_.r(a);var v=_(26),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),_("p",[_("code",[t._v("JavaScript")]),t._v("分为 2 种数据类型："),_("code",[t._v("原始类型")]),t._v("和"),_("code",[t._v("引用类型")]),t._v("。")]),t._v(" "),_("p",[t._v("原始类型数据存放在"),_("code",[t._v("栈")]),t._v("中，引用类型数据存放在"),_("code",[t._v("堆")]),t._v("中。")]),t._v(" "),_("div",{staticStyle:{display:"flex",width:"100%"}},[_("img",{staticStyle:{width:"50%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga1.png"}}),t._v(" "),_("img",{staticStyle:{width:"50%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga2.png"}})]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" dog "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" foods"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ndog"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foods "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[_("code",[t._v("foods")]),t._v(" 的指向改变了， 此时堆中的数组对象就成为了不被使用的数据，专业名词叫「不可达」的数据。\n这就是需要回收的垃圾数据。")]),t._v(" "),_("h2",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),_("p",[t._v("可以将这个过程想象成从根溢出一个巨大的油漆桶，它从一个根节点出发将可到达的对象标记染色， 然后移除未标记的。")]),t._v(" "),_("h3",{attrs:{id:"第一步-标记空间中「可达」值。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一步-标记空间中「可达」值。"}},[t._v("#")]),t._v(" 第一步：标记空间中「可达」值。")]),t._v(" "),_("p",[_("code",[t._v("V8")]),t._v(" 采用的是可达性 ("),_("code",[t._v("reachability")]),t._v(") 算法来判断堆中的对象应不应该被回收。这个算法的思路是这样的：")]),t._v(" "),_("p",[t._v("从根节点（Root）出发，遍历所有的对象。")]),t._v(" "),_("p",[t._v("可以遍历到的对象，是可达的（"),_("code",[t._v("reachable")]),t._v("）。\n没有被遍历到的对象，不可达的（"),_("code",[t._v("unreachable")]),t._v("）。")]),t._v(" "),_("p",[t._v("在浏览器环境下，根节点有很多，主要包括这几种：")]),t._v(" "),_("ul",[_("li",[t._v("全局变量 window，位于每个 iframe 中；")]),t._v(" "),_("li",[t._v("文档 DOM 树；")]),t._v(" "),_("li",[t._v("存放在栈上的变量；")])]),t._v(" "),_("p",[t._v("...\n这些根节点不是垃圾，不可能被回收。")]),t._v(" "),_("h3",{attrs:{id:"第二步-回收「不可达」的值所占据的内存。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二步-回收「不可达」的值所占据的内存。"}},[t._v("#")]),t._v(" 第二步：回收「不可达」的值所占据的内存。")]),t._v(" "),_("p",[t._v("在所有的标记完成之后，统一清理内存中所有不可达的对象。")]),t._v(" "),_("h3",{attrs:{id:"第三步-做内存整理。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三步-做内存整理。"}},[t._v("#")]),t._v(" 第三步，做内存整理。")]),t._v(" "),_("p",[t._v("在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。")]),t._v(" "),_("p",[t._v("当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。")]),t._v(" "),_("p",[t._v("所以最后一步是整理内存碎片。(但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。)")]),t._v(" "),_("h2",{attrs:{id:"什么时候垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么时候垃圾回收"}},[t._v("#")]),t._v(" 什么时候垃圾回收？")]),t._v(" "),_("p",[t._v("浏览器进行垃圾回收的时候，会暂停 "),_("code",[t._v("JavaScript")]),t._v(" 脚本，等垃圾回收完毕再继续执行。")]),t._v(" "),_("p",[t._v("对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂停时间很长就会造成页面卡顿。")]),t._v(" "),_("p",[t._v("这就是我们接下来谈的关于垃圾回收的问题：什么时候进行垃圾回收，可以避免长时间暂停。")]),t._v(" "),_("h3",{attrs:{id:"分代收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分代收集"}},[t._v("#")]),t._v(" 分代收集")]),t._v(" "),_("p",[t._v("浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象。")]),t._v(" "),_("h4",{attrs:{id:"临时对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#临时对象"}},[t._v("#")]),t._v(" 临时对象：")]),t._v(" "),_("p",[t._v("大部分对象在内存中存活的时间很短；")]),t._v(" "),_("p",[t._v("比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁；")]),t._v(" "),_("p",[t._v("这类对象很快就变得不可访问，应该快点回收。")]),t._v(" "),_("h4",{attrs:{id:"长久对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#长久对象"}},[t._v("#")]),t._v(" 长久对象：")]),t._v(" "),_("p",[t._v("生命周期很长的对象，比如全局的 window、DOM、Web API 等等；")]),t._v(" "),_("p",[t._v("这类对象可以慢点回收。")]),t._v(" "),_("p",[t._v("这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域， 新生代中存放临时对象，老生代中存放持久对象。")]),t._v(" "),_("p",[t._v("并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。这样就可以实现高效的垃圾回收啦。")]),t._v(" "),_("h4",{attrs:{id:"主垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[t._v("#")]),t._v(" 主垃圾回收器")]),t._v(" "),_("p",[t._v("负责老生代的垃圾回收，有两个特点：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("对象占用空间大；")])]),t._v(" "),_("li",[_("p",[t._v("对象存活时间长。")])])]),t._v(" "),_("p",[t._v("它使用「标记-清除」的算法执行垃圾回收。")]),t._v(" "),_("p",[t._v("首先是标记。\n从一组根元素开始，递归遍历这组根元素；")]),t._v(" "),_("p",[t._v("在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。")]),t._v(" "),_("p",[t._v("然后是垃圾清除。")]),t._v(" "),_("p",[t._v("直接将标记为垃圾的数据清理掉。\n多次标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理。")]),t._v(" "),_("div",{staticStyle:{display:"flex",width:"100%"}},[_("img",{staticStyle:{width:"50%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_01.webp"}}),t._v(" "),_("img",{staticStyle:{width:"50%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_02.webp"}})]),t._v(" "),_("h4",{attrs:{id:"副垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),_("p",[t._v("负责新生代的垃圾回收，通常只支持 1~8 M 的容量。")]),t._v(" "),_("p",[t._v("新生代被分为两个区域：一般是对象区域，一半是空闲区域。")]),t._v(" "),_("img",{staticStyle:{width:"80%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_03.webp"}}),t._v(" "),_("p",[t._v("新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。")]),t._v(" "),_("p",[t._v("先给对象区域所有垃圾做标记；")]),t._v(" "),_("p",[t._v("标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍；")]),t._v(" "),_("img",{staticStyle:{width:"80%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_04.png"}}),t._v(" "),_("p",[t._v("这就回到我们前面留下的问题 -- 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了；")]),t._v(" "),_("p",[t._v("复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。这样，就完成了垃圾回收。")]),t._v(" "),_("img",{staticStyle:{width:"80%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_05.webp"}}),t._v(" "),_("p",[t._v("这样，就完成了垃圾回收。")]),t._v(" "),_("p",[t._v("因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。")]),t._v(" "),_("h5",{attrs:{id:"分代收集-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分代收集-2"}},[t._v("#")]),t._v(" 分代收集")]),t._v(" "),_("p",[t._v("一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。")]),t._v(" "),_("img",{staticStyle:{width:"80%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_06.webp"}}),t._v(" "),_("h5",{attrs:{id:"增量收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#增量收集"}},[t._v("#")]),t._v(" 增量收集")]),t._v(" "),_("p",[t._v("如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。")]),t._v(" "),_("p",[t._v("这样就解决了长时间停顿的问题。")]),t._v(" "),_("img",{staticStyle:{width:"80%"},attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/ga_img_07.webp"}}),t._v(" "),_("h5",{attrs:{id:"闲时收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闲时收集"}},[t._v("#")]),t._v(" 闲时收集")]),t._v(" "),_("p",[t._v("垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。")]),t._v(" "),_("h2",{attrs:{id:"常见问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),_("ol",[_("li",[t._v("浏览器怎么进行垃圾回收？")])]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("查看")]),t._v(" "),_("p",[t._v("从三个点来回答什么是垃圾、如何捡垃圾、什么时候捡垃圾。")]),t._v(" "),_("p",[t._v("什么是垃圾？")]),t._v(" "),_("p",[t._v("不再需要，即为垃圾；")]),t._v(" "),_("p",[t._v("全局变量随时可能用到，所以一定不是垃圾。")]),t._v(" "),_("p",[t._v("如何捡垃圾（遍历算法）？")]),t._v(" "),_("p",[t._v("标记空间中「可达」值：")]),t._v(" "),_("p",[t._v("从根节点（Root）出发，遍历所有的对象；")]),t._v(" "),_("p",[t._v("可以遍历到的对象，是可达的（reachable）；")]),t._v(" "),_("p",[t._v("没有被遍历到的对象，不可达的（unreachable）。")]),t._v(" "),_("p",[t._v("回收「不可达」的值所占据的内存。")]),t._v(" "),_("p",[t._v("做内存整理。")]),t._v(" "),_("p",[t._v("什么时候捡垃圾？")]),t._v(" "),_("p",[t._v("前端有其特殊性，垃圾回收的时候会造成页面卡顿；")]),t._v(" "),_("p",[t._v("分代收集、增量收集、闲时收集。")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("浏览器中不同类型变量的内存何时释放？")])]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("查看")]),t._v(" "),_("p",[t._v("Javascritp 中类型：值类型，引用类型。")]),t._v(" "),_("p",[t._v("引用类型：")]),t._v(" "),_("p",[t._v("在没有引用之后，通过 V8 自动回收。")]),t._v(" "),_("p",[t._v("值类型：")]),t._v(" "),_("p",[t._v("如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收；")]),t._v(" "),_("p",[t._v("非闭包的情况下，等待 V8 的新生代切换的时候回收。")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("哪些情况会导致内存泄露？如何避免？")])]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("查看")]),t._v(" "),_("p",[t._v("内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。")]),t._v(" "),_("p",[t._v("以 Vue 为例，通常有这些情况：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("监听在 window/body 等事件没有解绑；")])]),t._v(" "),_("li",[_("p",[t._v("绑在 EventBus 的事件没有解绑；")])]),t._v(" "),_("li",[_("p",[t._v("Vuex 的 $store，watch 了之后没有 unwatch；")])]),t._v(" "),_("li",[_("p",[t._v("使用第三方库创建，没有调用正确的销毁函数。")])])]),t._v(" "),_("p",[t._v("解决办法：beforeDestroy 中及时销毁：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener；")])]),t._v(" "),_("li",[_("p",[t._v("观察者模式 $on，$off 处理；")])]),t._v(" "),_("li",[_("p",[t._v("如果组件中使用了定时器，应销毁处理；")])]),t._v(" "),_("li",[_("p",[t._v("如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁；")])]),t._v(" "),_("li",[_("p",[t._v("使用弱引用 weakMap、weakSet。")])])])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("闭包会导致内存泄露吗？")])]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("查看")]),t._v(" "),_("p",[t._v("顺便说一个我在了解垃圾回收之前对闭包的误解。闭包会导致内存泄露吗？正确的答案是不会。")]),t._v(" "),_("p",[t._v("内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。")]),t._v(" "),_("p",[t._v("这个误解是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。参考这篇文章。")]),t._v(" "),_("p",[t._v("https://zhuanlan.zhihu.com/p/22486908")])]),t._v(" "),_("p",[t._v("本文转载自"),_("a",{attrs:{href:"https://mp.weixin.qq.com/s/G02qgYGbAxvUeQeQzMBjnA",target:"_blank",rel:"noopener noreferrer"}},[t._v("垃圾回收"),_("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);