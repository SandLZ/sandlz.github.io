(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{448:function(v,_,e){"use strict";e.r(_);var t=e(26),c=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[v._v("#")]),v._v(" Http")]),v._v(" "),e("blockquote",[e("p",[v._v("本篇是对 HTTP 不同版本主要特性的一个概述和总结。")])]),v._v(" "),e("h2",{attrs:{id:"发展历史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发展历史"}},[v._v("#")]),v._v(" 发展历史")]),v._v(" "),e("ul",[e("li",[v._v("1991 年 版本："),e("code",[v._v("0.9")]),v._v(" : 只有一个命令 "),e("code",[v._v("GET")]),v._v(", 只能响应 "),e("code",[v._v("HTML")])]),v._v(" "),e("li",[v._v("1996 年 版本："),e("code",[v._v("1.0")]),v._v(" : 引入"),e("code",[v._v("POST")]),v._v("、"),e("code",[v._v("HEAD")]),v._v(", 增加"),e("code",[v._v("Header")]),v._v(", 响应格式丰富")]),v._v(" "),e("li",[v._v("1997 年 版本："),e("code",[v._v("1.1")]),v._v(" : 引入"),e("code",[v._v("持久连接")]),v._v("、管道机制、"),e("code",[v._v("PUT")]),v._v("、"),e("code",[v._v("PATCH")]),v._v("、"),e("code",[v._v("OPTIONS")]),v._v("、"),e("code",[v._v("DELETE")]),v._v(", 新增"),e("code",[v._v("Host")]),v._v("字段")]),v._v(" "),e("li",[v._v("20015 版本："),e("code",[v._v("2")]),v._v(" : 二进制、多工、头压缩、服务器推送")])]),v._v(" "),e("h2",{attrs:{id:"http-1-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP 1.0")])]),v._v(" "),e("p",[v._v("早先"),e("code",[v._v("1.0")]),v._v("的"),e("code",[v._v("HTTP")]),v._v("版本，是一种无状态、无连接的应用层协议。")]),v._v(" "),e("p",[e("code",[v._v("HTTP1.0")]),v._v(" 规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个"),e("code",[v._v("TCP")]),v._v("连接，服务器处理完成后立即断开"),e("code",[v._v("TCP")]),v._v("连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。")]),v._v(" "),e("p",[v._v("这种无状态性可以借助"),e("code",[v._v("cookie/session")]),v._v("机制来做身份认证和状态记录。而下面两个问题就比较麻烦了。")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("首先，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次"),e("code",[v._v("TCP")]),v._v("的连接，而"),e("code",[v._v("TCP")]),v._v("的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。")])]),v._v(" "),e("li",[e("p",[v._v("其次就是队头阻塞（"),e("code",[v._v("head of line blocking")]),v._v("）。由于"),e("code",[v._v("HTTP1.0")]),v._v("规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。")])])]),v._v(" "),e("p",[v._v("为了解决这些问题，"),e("code",[v._v("HTTP1.1")]),v._v("出现了。")]),v._v(" "),e("h2",{attrs:{id:"http-1-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP 1.1")])]),v._v(" "),e("p",[v._v("对于"),e("code",[v._v("HTTP1.1")]),v._v("，不仅继承了"),e("code",[v._v("HTTP1.0")]),v._v("简单的特点，还克服了诸多"),e("code",[v._v("HTTP1.0")]),v._v("性能上的问题。")]),v._v(" "),e("p",[v._v("首先是长连接，"),e("code",[v._v("HTTP1.1")]),v._v("增加了一个"),e("code",[v._v("Connection")]),v._v("字段，通过设置"),e("code",[v._v("Keep-Alive")]),v._v("可以保持"),e("code",[v._v("HTTP")]),v._v("连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立"),e("code",[v._v("TCP")]),v._v("连接，提高了网络的利用率。如果客户端想关闭"),e("code",[v._v("HTTP")]),v._v("连接，可以在请求头中携带"),e("code",[v._v("Connection: false")]),v._v("来告知服务器关闭请求。")]),v._v(" "),e("p",[v._v("其次，是"),e("code",[v._v("HTTP1.1")]),v._v("支持请求管道化（"),e("code",[v._v("pipelining")]),v._v("）。基于"),e("code",[v._v("HTTP1.1")]),v._v("的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个 html 页面，页面中包含了很多 img，这个时候"),e("code",[v._v("keep-alive")]),v._v("就起了很大的作用，能够进行“并行”发送多个请求。（注意这里的“并行”并不是真正意义上的并行传输，具体解释如下。）")]),v._v(" "),e("p",[v._v("需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。")]),v._v(" "),e("p",[v._v("也就是说，"),e("code",[v._v("HTTP")]),v._v("管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。")]),v._v(" "),e("div",[e("img",{attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/http_01.png"}})]),v._v(" "),e("p",[v._v("如图所示，客户端同时发了两个请求分别来获取"),e("code",[v._v("html")]),v._v("和"),e("code",[v._v("css")]),v._v("，假如说服务器的"),e("code",[v._v("css")]),v._v("资源先准备就绪，服务器也会先发送"),e("code",[v._v("html")]),v._v("再发送"),e("code",[v._v("css")]),v._v("。")]),v._v(" "),e("p",[v._v("换句话来说，只有等到"),e("code",[v._v("html")]),v._v("响应的资源完全传输完毕后，"),e("code",[v._v("css")]),v._v("响应的资源才能开始传输。也就是说，不允许同时存在两个并行的响应。")]),v._v(" "),e("p",[v._v("可见，"),e("code",[v._v("HTTP1.1")]),v._v("还是无法解决队头阻塞（"),e("code",[v._v("head of line blocking")]),v._v("）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么就直接默认关闭，并且开启的条件很苛刻...而且实际上好像并没有什么用处。")]),v._v(" "),e("div",[e("img",{attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/http_02.png"}})]),v._v("\n如图所示，绿色部分代表请求发起到服务器响应的一个等待时间，而蓝色部分表示资源的下载时间。按照理论来说，`HTTP`响应理应当是前一个响应的资源下载完了，下一个响应的资源才能开始下载。而这里却出现了响应资源下载并行的情况。这又是为什么呢？\n"),e("p",[v._v("其实，虽然 "),e("code",[v._v("HTTP1.1")]),v._v(" 支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个 "),e("code",[v._v("TCP")]),v._v(" 的会话。也就是说，上图我们看到的并行，其实是不同的 "),e("code",[v._v("TCP")]),v._v(" 连接上的 "),e("code",[v._v("HTTP")]),v._v(" 请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载 "),e("code",[v._v("6~8")]),v._v(" 个资源的限制。而这，才是真正的并行！")]),v._v(" "),e("p",[v._v("此外，"),e("code",[v._v("HTTP1.1")]),v._v(" 还加入了 "),e("RouterLink",{attrs:{to:"/base/browser/cache.html"}},[v._v("缓存处理")]),v._v(" 新的字段如 "),e("code",[v._v("cache-control")]),v._v("，支持断点传输，以及增加了 "),e("code",[v._v("Host")]),v._v(" 字段（使得一个服务器能够用来创建多个 Web 站点）。")],1),v._v(" "),e("h2",{attrs:{id:"http-2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP 2.0")])]),v._v(" "),e("p",[v._v("新特性:")]),v._v(" "),e("h3",{attrs:{id:"二进制分帧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[v._v("#")]),v._v(" 二进制分帧")]),v._v(" "),e("p",[v._v("HTTP2.0 通过在应用层和传输层之间增加一个二进制分帧层，突破了 HTTP1.1 的性能限制、改进传输性能。")]),v._v(" "),e("div",[e("img",{attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/http_03.jpeg"}})]),v._v(" "),e("p",[v._v("可见，虽然"),e("code",[v._v("HTTP2.0")]),v._v("的协议和"),e("code",[v._v("HTTP1.x")]),v._v("协议之间的规范完全不同了，但是实际上"),e("code",[v._v("HTTP2.0")]),v._v("并没有改变"),e("code",[v._v("HTTP1.x")]),v._v("的语义。\n简单来说，"),e("code",[v._v("HTTP2.0")]),v._v("只是把原来"),e("code",[v._v("HTTP1.x")]),v._v("的"),e("code",[v._v("header")]),v._v("和"),e("code",[v._v("body")]),v._v("部分用"),e("code",[v._v("frame")]),v._v("重新封装了一层而已。")]),v._v(" "),e("h3",{attrs:{id:"多路复用-连接共享"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用-连接共享"}},[v._v("#")]),v._v(" 多路复用（连接共享）")]),v._v(" "),e("ul",[e("li",[v._v("流（"),e("code",[v._v("stream")]),v._v("）：已建立连接上的双向字节流")]),v._v(" "),e("li",[v._v("消息：与逻辑消息对应的完整的一系列数据帧")]),v._v(" "),e("li",[v._v("帧（"),e("code",[v._v("frame")]),v._v("）："),e("code",[v._v("HTTP2.0")]),v._v("通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（"),e("code",[v._v("stream id")]),v._v("）")])]),v._v(" "),e("div",[e("img",{attrs:{src:"https://gitee.com/sandlz/images/raw/master/uPic/http_04.jpeg"}})]),v._v(" "),e("p",[v._v("从图中可见，所有的"),e("code",[v._v("HTTP2.0")]),v._v("通信都在一个"),e("code",[v._v("TCP")]),v._v("连接上完成，这个连接可以承载任意数量的双向数据流。")]),v._v(" "),e("p",[v._v("每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（"),e("code",[v._v("stream id")]),v._v("）重新组装。")]),v._v(" "),e("p",[v._v("举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着"),e("code",[v._v("stream id")]),v._v("用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据"),e("code",[v._v("stream id")]),v._v("将帧再归属到各自不同的请求当中去。")]),v._v(" "),e("p",[v._v("另外，多路复用（连接共享）可能会导致关键请求被阻塞。"),e("code",[v._v("HTTP2.0")]),v._v("里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。")]),v._v(" "),e("p",[v._v("可见，"),e("code",[v._v("HTTP2.0")]),v._v("实现了真正的并行传输，它能够在一个"),e("code",[v._v("TCP")]),v._v("上进行任意数量"),e("code",[v._v("HTTP")]),v._v("请求。而这个强大的功能则是基于“二进制分帧”的特性。")]),v._v(" "),e("h3",{attrs:{id:"头部压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[v._v("#")]),v._v(" 头部压缩")]),v._v(" "),e("p",[v._v("在"),e("code",[v._v("HTTP1.x")]),v._v("中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加"),e("code",[v._v("500~800")]),v._v("字节的负荷。")]),v._v(" "),e("p",[v._v("比如说"),e("code",[v._v("cookie")]),v._v("，默认情况下，浏览器会在每次请求的时候，把"),e("code",[v._v("cookie")]),v._v("附在"),e("code",[v._v("header")]),v._v("上面发送给服务器。（由于"),e("code",[v._v("cookie")]),v._v("比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）")]),v._v(" "),e("p",[e("code",[v._v("HTTP2.0")]),v._v("使用"),e("code",[v._v("encoder")]),v._v("来减少需要传输的"),e("code",[v._v("header")]),v._v("大小，通讯双方各自"),e("code",[v._v("cache")]),v._v("一份"),e("code",[v._v("header fields")]),v._v("表，既避免了重复"),e("code",[v._v("header")]),v._v("的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩"),e("code",[v._v("header")]),v._v("，减少发送包的数量从而降低延迟。`")]),v._v(" "),e("h3",{attrs:{id:"服务器推送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[v._v("#")]),v._v(" 服务器推送")]),v._v(" "),e("p",[v._v("服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。")]),v._v(" "),e("h2",{attrs:{id:"http1-1-的合并请求是否适用于-http2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-的合并请求是否适用于-http2-0"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP1.1")]),v._v(" 的合并请求是否适用于 "),e("code",[v._v("HTTP2.0")])]),v._v(" "),e("p",[v._v("首先，答案是“没有必要”。之所以没有必要，是因为这跟 "),e("code",[v._v("HTTP2.0")]),v._v(" 的头部压缩有很大的关系。")]),v._v(" "),e("p",[v._v("在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典。")]),v._v(" "),e("p",[v._v("在静态字典中，包含了常见的头部名称以及头部名称与值的组合。静态字典在首次请求时就可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段对应的 index。")]),v._v(" "),e("p",[v._v("而动态字典跟连接的上下文相关，每个 "),e("code",[v._v("HTTP/2")]),v._v(" 连接维护的动态字典是不尽相同的。动态字典可以在连接中不听的进行更新。")]),v._v(" "),e("p",[v._v("也就是说，原本完整的 "),e("code",[v._v("HTTP")]),v._v(" 报文头部的键值对或字段，由于字典的存在，现在可以转换成索引 "),e("code",[v._v("index")]),v._v(" ，在相应的端再进行查找还原，也就起到了压缩的作用。")]),v._v(" "),e("p",[v._v("所以，同一个连接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对 "),e("code",[v._v("HTTP/2")]),v._v(" 网站，最佳实践是不要合并资源。")]),v._v(" "),e("p",[v._v("另外，"),e("code",[v._v("HTTP2.0")]),v._v(" 多路复用使得请求可以并行传输，而 "),e("code",[v._v("HTTP1.1")]),v._v(" 合并请求的一个原因也是为了防止过多的 HTTP 请求带来的阻塞问题。而现在 "),e("code",[v._v("HTTP2.0")]),v._v(" 已经能够并行传输了，所以合并请求也就没有必要了。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("h3",{attrs:{id:"http1-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP1.0")])]),v._v(" "),e("ul",[e("li",[v._v("无状态")]),v._v(" "),e("li",[v._v("无连接")])]),v._v(" "),e("h3",{attrs:{id:"http1-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP1.1")])]),v._v(" "),e("ul",[e("li",[v._v("持久连接")]),v._v(" "),e("li",[v._v("请求管道化")]),v._v(" "),e("li",[v._v("增加缓存处理（新的字段如 cache-control）")]),v._v(" "),e("li",[v._v("增加 "),e("code",[v._v("Host")]),v._v(" 字段、支持断点传输等")])]),v._v(" "),e("h3",{attrs:{id:"http2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[v._v("#")]),v._v(" "),e("code",[v._v("HTTP2.0")])]),v._v(" "),e("ul",[e("li",[v._v("二进制分帧")]),v._v(" "),e("li",[v._v("多路复用（或连接共享）")]),v._v(" "),e("li",[v._v("头部压缩")]),v._v(" "),e("li",[v._v("服务器推送")])]),v._v(" "),e("p",[v._v("本文转载自"),e("a",{attrs:{href:"https://segmentfault.com/a/1190000013028798",target:"_blank",rel:"noopener noreferrer"}},[v._v("HTTP主要特性对比"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=c.exports}}]);