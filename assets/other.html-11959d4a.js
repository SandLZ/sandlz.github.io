import{_ as e,p as a,q as o,a1 as s}from"./framework-201fec1f.js";const n={},c=s(`<h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h1><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由" aria-hidden="true">#</a> 路由</h2><ul><li><code>history</code></li><li><code>hash</code></li></ul><h3 id="history" tabindex="-1"><a class="header-anchor" href="#history" aria-hidden="true">#</a> <code>history</code></h3><p>API 简介：</p><ul><li><code>window.history.length</code> 当前会话浏览过的页面数量</li><li><code>window.history.go(?delta)</code> 根据参数在历史记录中移动</li><li><code>window.history.back()</code> 上一页 等于 <code>window.history.go(-1)</code></li><li><code>window.history.forward()</code> 下一页 等于 <code>window.history.go(1)</code></li><li><code>window.history.pushState(data, title, ?url)</code> 添加一条浏览记录</li><li><code>window.history.replaceState(data, title, ?url)</code> 修改一条浏览记录</li></ul><p>HTML5 的 History API 为浏览器的全局 history 对象增加了该扩展方法。它是一个浏览器的一个接口，在 window 对象中提供了 onpopstate 事件来监听历史栈的改变，只要历史栈有信息发生改变的话，就会触发该事件。提供了如下事件：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;popstate&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 <code>go</code> <code>back</code> <code>forward</code> <code>pushState</code> <code>replaceState</code> 均会触发上面的事件，并且浏览器的 url 地址也会跟着改变。只会改变 url 地址，且不会重新刷新页面。</p><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> <code>hash</code></h3><p><code>hash</code>路由模式是这样的：<code>http://xxx.abc.com/#/xx</code>。 有带<code>#</code>号，后面就是<code>hash</code>值的变化。改变后面的<code>hash</code>值，它不会向服务器发出请求，因此也就不会刷新页面。并且每次<code>hash</code>值发生改变的时候，会触发<code>hashchange</code>事件。因此我们可以通过监听该事件，来知道<code>hash</code>值发生了哪些变化。比如我们可以如下简单的监听：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;hashchange&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// location.hash</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改变<code>hash</code>不会触发页面跳转，因为<code>hash</code>链接是当前页面中的某个片段，所以如果<code>hash</code>有变化，那么页面将会滚动到<code>hash</code>所连接的位置。但是页面中如果不存在<code>hash</code>对应的片段，则没有任何效果。比如 <code>a</code>链接。这和 <code>window.history.pushState</code>方法类似，都是不刷新页面的情况下更改<code>url</code>。</p><p><code>hash</code>与<code>pushState</code>对比</p><ol><li><p><code>hash</code>只能修改<code>url</code>的片段标识符的部分。并且必须从<code>#</code>号开始，但是<code>pushState</code>且能修改路径、查询参数和片段标识符。<code>pushState</code>比<code>hash</code>更符合前端路由的访问方式，更加优雅(因为不带#号)。</p></li><li><p><code>hash</code>必须和原先的值不同，才能新增会话浏览历史的记录，但是<code>pushState</code>可以新增相同的<code>url</code>的记录</p></li></ol><p>不管我们是通过<code>location</code>接口直接改变<code>hash</code>值，还是我们通过<code>history</code>直接前进或后退操作(改变<code>hash</code>变化)，我们都可以看到都能通过 <code>hashchange</code>该事件进行监听到<code>url hash</code>的改变。并且不会刷新页面。</p>`,16),d=[c];function t(i,p){return a(),o("div",null,d)}const h=e(n,[["render",t],["__file","other.html.vue"]]);export{h as default};
