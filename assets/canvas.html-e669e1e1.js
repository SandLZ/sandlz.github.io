import{_ as t,p as d,q as e,a1 as a}from"./framework-201fec1f.js";const r={},i=a(`<h1 id="canvas" tabindex="-1"><a class="header-anchor" href="#canvas" aria-hidden="true">#</a> Canvas</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><blockquote><p>最初由 Apple 使用在 Safari 中，后来 Firefox/Chrome 分别实现，经过一段时间发展，成为 H5 标准。 Canvas 可理解为画布，栅格化的。</p></blockquote><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><p>小游戏、头像裁剪、Charts</p><h2 id="基本知识" tabindex="-1"><a class="header-anchor" href="#基本知识" aria-hidden="true">#</a> 基本知识</h2><p><img src="https://raw.githubusercontent.com/sandlz/images/master/uPic/Canvas入门.png" alt="image"></p><h3 id="坐标系、api、属性" tabindex="-1"><a class="header-anchor" href="#坐标系、api、属性" aria-hidden="true">#</a> 坐标系、API、属性</h3><h4 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h4><table><thead><tr><th style="text-align:center;">接口</th><th style="text-align:center;">作用</th><th style="text-align:center;">获取</th></tr></thead><tbody><tr><td style="text-align:center;">HTMLCanvasElement</td><td style="text-align:center;">Style、Context</td><td style="text-align:center;">getElementById(&#39;myCanvas&#39;)</td></tr><tr><td style="text-align:center;">CanvasRenderingContext2D</td><td style="text-align:center;">Draw</td><td style="text-align:center;">canvas.getContext(&#39;2d&#39;)</td></tr><tr><td style="text-align:center;">ImageData</td><td style="text-align:center;">像素操作</td><td style="text-align:center;">ctx.createImageData(x, y) <br> ctx.getImageData(sx, sy, sw, sh)</td></tr><tr><td style="text-align:center;">TextMetrics</td><td style="text-align:center;">计算宽度</td><td style="text-align:center;">ctx.measureText(text)</td></tr><tr><td style="text-align:center;">CanvasGradient</td><td style="text-align:center;">渐变的不透明对象</td><td style="text-align:center;">ctx.createLinearGradient() <br> ctx.createRadialGradient()</td></tr><tr><td style="text-align:center;">CanvasPattern</td><td style="text-align:center;">基于(image, canvas 或 video）的不透明对象</td><td style="text-align:center;">ctx.createPattern()</td></tr><tr><td style="text-align:center;"><em>Path2D(实验特性)</em></td><td style="text-align:center;">可以保留并重用的路径</td><td style="text-align:center;">new Path2D(?path, ?d) <br> new Path2D(otherPathObj)</td></tr></tbody></table><h4 id="property" tabindex="-1"><a class="header-anchor" href="#property" aria-hidden="true">#</a> Property</h4><table><tr><th style="width:60px;">分类</th><th style="width:100px;text-align:center;">类别</th><th>方法名</th><th>作用</th><th>备注</th></tr><tr><td rowspan="100">Style</td><td rowspan="7">Line</td><td>lineWidth</td><td>线宽</td><td></td></tr><tr><td>lineCap</td><td>线尾</td><td>&quot;butt&quot; || &quot;round&quot; || &quot;square&quot;</td></tr><tr><td>lineJoin</td><td>线相交</td><td>&quot;bevel&quot; || &quot;round&quot; || &quot;miter&quot;</td></tr><tr><td>miterLimit</td><td>斜接头</td><td></td></tr><tr><td>getLineDash()</td><td>虚线</td><td>返回：Array</td></tr><tr><td>setLineDash()</td><td>设置虚线</td><td></td></tr><tr><td>lineDashOffset</td><td>虚线偏移</td><td></td></tr><tr><td rowspan="4">Text</td><td>font</td><td>字体</td><td>默认：10px sans-serif</td></tr><tr><td>textAlign</td><td>对齐方式</td><td>start (默认), end, left, right, center</td></tr><tr><td>textBaseline</td><td>基线对齐方式</td><td> top, hanging, middle, alphabetic (默认), ideographic, bottom</td></tr><tr><td>direction</td><td>方向</td><td>ltr, rtl, inherit (默认)</td></tr><tr><td rowspan="1">Fill</td><td>fillStyle</td><td>填充样式</td><td>默认：#000，支持rgb、rgba、black等</td></tr><tr><td rowspan="1">Stroke</td><td>strokeStyle</td><td>描边样式</td><td>默认：#000，支持rgb、rgba、black等</td></tr><tr><td rowspan="4">Shadows</td><td>shadowBlur</td><td>模糊等级</td><td>默认：0</td></tr><tr><td>shadowColor</td><td>阴影色</td><td>默认：透明，支持rgb、rgba、black等<br>被fillStyle/strokeStyle影响</td></tr><tr><td>shadowOffsetX</td><td>水平方向偏移</td><td></td></tr><tr><td>shadowOffsetY</td><td>垂直方向偏移</td><td></td></tr><tr><td rowspan="2">Compositing</td><td>globalAlpha</td><td>透明度</td><td>默认：1</td></tr><tr><td>globalCompositeOperation</td><td>合成类型</td><td>可选值(12种)：source-over、source-in、source-out、<br>source-atop、destination-over、destination-in、<br>destination-out、destination-atop、lighter、copy、<br>xor、multiply、screen、overlay、darken、lighten、<br>color-dodge、color-burn、hard-light、<br>soft-light、difference、exclusion、hue、<br>saturation、color、luminosity</td></tr></table><h4 id="method" tabindex="-1"><a class="header-anchor" href="#method" aria-hidden="true">#</a> Method</h4><table><tr><th style="width:60px;">分类</th><th style="width:100px;text-align:center;">类别</th><th>方法名</th><th>作用</th><th>备注</th></tr><tr><td rowspan="10">路径</td><td rowspan="10">Path</td><td>beginPath()</td><td>开始路径</td><td></td></tr><tr><td>closePath()</td><td>结束路径</td><td></td></tr><tr><td>moveTo(x, y)</td><td>移动画笔</td><td></td></tr><tr><td>lineTo(x, y)</td><td>直线路径</td><td></td></tr><tr><td>quadraticCurveTo(cp1x, cp1y, x, y)</td><td>二次贝塞尔曲线</td><td>cp1x,cp1y为一个控制点，x,y为结束点</td></tr><tr><td>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</td><td>三次贝塞尔曲线</td><td>cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点</td></tr><tr><td>arc(x, y, radius, startAngle, endAngle, [, anticlockwise])</td><td>以（x,y）为圆心的以radius为半径的圆弧（圆）</td><td>anticlockwise 默认false 顺时针</td></tr><tr><td>arcTo(x1, y1, x2, y2, radius)</td><td>给定的控制点和半径画一段圆弧，再以直线连接两个控制点</td><td></td></tr><tr><td>ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle [, anticlockwise])</td><td>椭圆</td><td></td></tr><tr><td>rect(x, y, width, height)</td><td>矩形</td><td></td></tr><tr><td rowspan="20">绘制</td><td rowspan="7">Path</td><td>fill()</td><td>填充</td><td></td></tr><tr><td>stroke()</td><td>描边</td><td></td></tr><tr><td>drawFocusIfNeeded([path], element)</td><td>聚焦的元素绘制路径</td><td></td></tr><tr><td>scrollPathIntoView([path])</td><td>滚动至路径</td><td></td></tr><tr><td>clip([path, fillRule])</td><td>裁剪</td><td>路径裁剪<br>fillRule: nonzero(默认) <br>evenodd(奇偶)</td></tr><tr><td>isPointInPath([path], x, y [, fillRule])</td><td>点是否在路径内</td><td>路径裁剪<br>fillRule: nonzero(默认) <br>evenodd(奇偶)</td></tr><tr><td>isPointInStroke([path], x, y)</td><td>点是否在描边路径内</td><td>路径裁剪<br>fillRule: nonzero(默认) <br>evenodd(奇偶)</td></tr><tr><td rowspan="3">Rect</td><td>fillRect(x, y, width, height)</td><td>填充</td><td></td></tr><tr><td>strokeRect(x, y, width, height)</td><td>描边</td><td></td></tr><tr><td>clearRect(x, y, width, height)</td><td>清除</td><td></td></tr><tr><td rowspan="3">Text</td><td>fillText(text, x, y [, maxWidth])</td><td>填充文本</td><td></td></tr><tr><td>strokeText(text, x, y [, maxWidth])</td><td>描边文本</td><td></td></tr><tr><td>measureText(text)</td><td>测量文本</td><td>返回：TextMetrics <br> {width ...}</td></tr><tr><td rowspan="1">Image</td><td>drawImage(image, dx, dy)<br>drawImage(image, dx, dy, dWidth, dHeight)<br>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</td><td>绘制图片</td><td>image: CanvasImageSource, 包含：<br>HTMLImageElement<br>SVGImageElement<br>HTMLVideoElement<br>HTMLCanvasElement<br>ImageBitmap<br>OffscreenCanvas</td></tr><tr><td rowspan="6">Transformations</td><td>getTransform()</td><td>当前变换矩阵</td><td>返回：DOMMatrix</td></tr><tr><td>rotate(angle)</td><td>旋转</td><td></td></tr><tr><td>scale(x, y)</td><td>缩放</td><td>默认缩放中心点(0, 0)</td></tr><tr><td>translate(x, y)</td><td>平移</td><td></td></tr><tr><td>transform(a, b, c, d, e, f)</td><td>变换</td><td></td></tr><tr><td>setTransform(a, b, c, d, e, f)<br>setTransform(matrix)</td><td>设置变换</td><td></td></tr><tr><td rowspan="20">其他</td><td rowspan="3">Pixel manipulation</td><td>createImageData(width, height)<br>createImageData(imagedata)</td><td>创建ImageData</td><td></td></tr><tr><td>getImageData(sx, sy, sw, sh)</td><td>获取图片数据</td><td>返回：ImageData</td></tr><tr><td>putImageData(imageData, dx, dy)<br>putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)</td><td>设置ImageData</td><td></td></tr><tr><td rowspan="2">State</td><td>save()</td><td>保存当前样式状态</td><td></td></tr><tr><td>restore()</td><td>恢复保存的样式状态(栈顶)</td><td></td></tr></table><h2 id="样式" tabindex="-1"><a class="header-anchor" href="#样式" aria-hidden="true">#</a> 样式</h2><p>上色：填充、描边</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>fillStyle
strokeStyle
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>颜色支持 5 种类型</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>yellow
#FFA500
rgb(255,165,0)
rgba(255,165,0, 0.5)
hsl(45, 100%, 50%)
hsla(45, 100%, 50%, 0.5)
CanvasGradient
CanvasPattern
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>画笔</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lineWidth
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="形状" tabindex="-1"><a class="header-anchor" href="#形状" aria-hidden="true">#</a> 形状</h2><p>概念：路径</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 开始新的路径
beginPath()
# 闭合当前路径
closePath
# 可创建子路径
ctx.moveTo(300, 0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线" tabindex="-1"><a class="header-anchor" href="#线" aria-hidden="true">#</a> 线</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ctx.lineTo(200, 300)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="矩形-rect" tabindex="-1"><a class="header-anchor" href="#矩形-rect" aria-hidden="true">#</a> 矩形: Rect</h3><p>创建矩形有 2 种方式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 1. fillRect / strokeRect
ctx.fillRect(0, 0, 200, 200)
# 2. Path2D
Path2D.rect(0, 0, 200, 200)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="弧-arc" tabindex="-1"><a class="header-anchor" href="#弧-arc" aria-hidden="true">#</a> 弧：Arc</h3><p>圆、椭圆</p><div style="width:100%;"><img style="width:33%;" src="https://github.com/sandlz/images/raw/master/uPic/arc.jpg"><img style="width:33%;" src="https://github.com/sandlz/images/raw/master/uPic/arcTo_02.jpg"><img style="width:33%;" src="https://github.com/sandlz/images/raw/master/uPic/eliipse.jpg"></div><h3 id="曲线-bezier" tabindex="-1"><a class="header-anchor" href="#曲线-bezier" aria-hidden="true">#</a> 曲线 ：Bezier</h3><p><img src="https://github.com/sandlz/images/raw/master/uPic/54diwjdj8b.gif" alt="image"><img src="https://github.com/sandlz/images/raw/master/uPic/mhmuin6c2w.gif" alt="image"></p><h3 id="fillrule" tabindex="-1"><a class="header-anchor" href="#fillrule" aria-hidden="true">#</a> fillRule</h3><p><img src="https://github.com/sandlz/images/raw/master/uPic/Even-odd_and_non-zero_winding_fill_rules3.jpg" alt="image"></p><h2 id="变换" tabindex="-1"><a class="header-anchor" href="#变换" aria-hidden="true">#</a> 变换</h2><p><img src="https://github.com/sandlz/images/raw/master/uPic/EVw5K5.png" alt="image"></p><h2 id="文字" tabindex="-1"><a class="header-anchor" href="#文字" aria-hidden="true">#</a> 文字</h2><p>水平、垂直方向 <img src="https://github.com/sandlz/images/raw/master/uPic/OelvkD.png" alt="image"><img src="https://github.com/sandlz/images/raw/master/uPic/BJwOpR.png" alt="image"></p><h2 id="图片" tabindex="-1"><a class="header-anchor" href="#图片" aria-hidden="true">#</a> 图片</h2><p>图片绘制支持多种来源</p><h2 id="动画" tabindex="-1"><a class="header-anchor" href="#动画" aria-hidden="true">#</a> 动画</h2><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2>`,44),n=[i];function s(l,h){return d(),e("div",null,n)}const o=t(r,[["render",s],["__file","canvas.html.vue"]]);export{o as default};
