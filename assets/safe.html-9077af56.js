import{_ as a,p as e,q as s,a1 as n}from"./framework-201fec1f.js";const i={},o=n(`<h1 id="安全" tabindex="-1"><a class="header-anchor" href="#安全" aria-hidden="true">#</a> 安全</h1><h2 id="xss-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#xss-跨站脚本攻击" aria-hidden="true">#</a> XSS 跨站脚本攻击</h2><p>描述：注入非法的css或js, 控制浏览器</p><h3 id="dom-xss" tabindex="-1"><a class="header-anchor" href="#dom-xss" aria-hidden="true">#</a> Dom XSS</h3><p>描述：利用Dom API</p><h3 id="反射型-xss" tabindex="-1"><a class="header-anchor" href="#反射型-xss" aria-hidden="true">#</a> 反射型 XSS</h3><p>描述：也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。 发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。</p><h3 id="存储型-xss" tabindex="-1"><a class="header-anchor" href="#存储型-xss" aria-hidden="true">#</a> 存储型 XSS</h3><p>描述：也被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板</p><p>比如</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何预防？</p><ol><li>校验输入（前后端）</li><li>字符串转义</li></ol><h2 id="csrf-cross-site-reuqest-forgeries-跨站点请求伪造" tabindex="-1"><a class="header-anchor" href="#csrf-cross-site-reuqest-forgeries-跨站点请求伪造" aria-hidden="true">#</a> CSRF（Cross Site Reuqest Forgeries） 跨站点请求伪造</h2><p>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</p><p>本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。 CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。</p><p>如何预防？</p><ol><li>验证码</li><li>token</li></ol><h2 id="clickjacking" tabindex="-1"><a class="header-anchor" href="#clickjacking" aria-hidden="true">#</a> Clickjacking</h2><p>描述：点击劫持</p><p>点击劫持，是指利用透明的按钮或连接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下， 点击那个连接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing) 。</p><p>手段: iframe、图片</p><p>如何防御？</p><ol><li>X-FRAME-OPTIONS : 服务端配置，允许一个页面可否在<code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记： DENY SAMEORIGIN ALLOW-FROM url</li></ol><h2 id="cookie-安全" tabindex="-1"><a class="header-anchor" href="#cookie-安全" aria-hidden="true">#</a> Cookie 安全</h2><ol><li>cookie签名</li><li>内容加密</li><li>响应头：http-only,禁止js读取cookie</li><li>secure字段：只允许在https下调用</li><li>same-site</li></ol>`,26),t=[o];function r(c,l){return e(),s("div",null,t)}const d=a(i,[["render",r],["__file","safe.html.vue"]]);export{d as default};
